<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Miro App MCP Demo</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
  <style>
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 16px; }
    .row { margin-bottom: 12px; }
    button { padding: 10px 12px; border: 0; border-radius: 8px; cursor: pointer; }
    button.primary { background: #4262ff; color: #fff; }
    button.secondary { background: #e6e8ff; color: #1b1f3b; }
    .hint { font-size: 12px; opacity: .75; }
    code { background: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <h2>Miro App MCP Demo</h2>

  <div class="row">
    <button id="btnAnalyze" class="primary">Analyze OKR from selected PDF</button>
    <div class="hint">Select a PDF on the board, then click.</div>
  </div>

  <div class="row">
    <button id="btnTable" class="secondary">Table â†’ Stickies (via MCP)</button>
    <div class="hint">Select a table-like area (or keep default) and run.</div>
  </div>

<script>
(async () => {
  // ============================
  // Config
  // ============================
  const BACKEND_URL = ""; // same origin
  const MODEL = "gpt-5.2";

  // Lovable config
  const TARGET_FRAME_TITLE = "lovable"; // case-insensitive match
  const LOVABLE_BASE_URL = "https://lovable.dev/?autosubmit=true#prompt=";

  // Board Button config
  const APPDATA_BUTTON_ID_KEY = "lovableButtonShapeId";
  const APPDATA_FRAME_ID_KEY = "lovableFrameId";
  const BUTTON_MARKER = "[[LOVABLE_BUTTON]]";
  const BUTTON_LABEL_TEXT = "ðŸš€ Lovable: Generate App";
  const BUTTON_SUBTEXT = `Click to open Lovable with this board + frame "${TARGET_FRAME_TITLE}"`;

  // ============================
  // Helpers
  // ============================
  async function notifyInfo(msg) {
    try { await miro.board.notifications.showInfo(msg); } catch (e) {}
  }
  async function notifyError(msg) {
    try { await miro.board.notifications.showError(msg); } catch (e) {}
  }

  async function getAppDataKey(key) {
    try {
      const val = await miro.board.getAppData(key);
      return val || null;
    } catch (e) {
      return null;
    }
  }

  async function setAppDataKey(key, val) {
    try {
      await miro.board.setAppData(key, String(val));
    } catch (e) {}
  }

  function normalizeTitle(s) {
    return String(s || "").trim().toLowerCase();
  }

  async function findTargetFrame() {
    // Prefer saved id first
    const saved = await getAppDataKey(APPDATA_FRAME_ID_KEY);
    if (saved) {
      try {
        const f = await miro.board.get({ id: saved });
        if (Array.isArray(f) && f.length && f[0].type === "frame") return f[0];
      } catch (e) {}
    }

    // else find by title
    const frames = await miro.board.get({ type: ["frame"] });
    for (const f of frames || []) {
      if (normalizeTitle(f.title) === normalizeTitle(TARGET_FRAME_TITLE)) return f;
    }
    return null;
  }

  function shapeHasMarker(shape) {
    const content = String(shape && shape.content ? shape.content : "");
    return content.indexOf(BUTTON_MARKER) !== -1;
  }

  function shapeLooksLikeButton(shape) {
    const content = String(shape && shape.content ? shape.content : "").toLowerCase();
    return content.indexOf("lovable") !== -1 && content.indexOf("generate") !== -1;
  }

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }

  function toHtmlButtonContent(boardId) {
    const prompt = buildLovablePrompt(boardId);
    const url = buildLovableUrl(prompt);

    // Make the button label a real hyperlink.
    // This improves reliability for collaborators because the link is a normal Miro hyperlink
    // (does not depend on the app runtime / events).
    const linkLabel =
      `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit;">` +
      `${escapeHtml(BUTTON_LABEL_TEXT)}` +
      `</a>`;

    return (
      `<p><strong>${linkLabel}</strong></p>` +
      `<p style="font-size:12px;opacity:.8;">${escapeHtml(BUTTON_SUBTEXT)}</p>` +
      `<p style="font-size:10px;opacity:.01;">${BUTTON_MARKER}</p>`
    );
  }

  async function getShapeById(id) {
    if (!id) return null;
    try {
      const arr = await miro.board.get({ id: id });
      if (Array.isArray(arr) && arr.length) return arr[0];
      if (arr && typeof arr === "object") return arr;
    } catch (e) {}
    return null;
  }

  async function findExistingButtonShape() {
    const savedId = await getAppDataKey(APPDATA_BUTTON_ID_KEY);
    if (savedId) {
      const item = await getShapeById(savedId);
      if (item && item.type === "shape") return item;
    }

    // Fallback: scan shapes
    const shapes = await miro.board.get({ type: ["shape"] });
    for (const s of shapes || []) {
      if (shapeHasMarker(s)) return s;
    }
    for (const s of shapes || []) {
      if (shapeLooksLikeButton(s)) return s;
    }
    return null;
  }

  // ============================
  // Ensure button exists in frame
  // ============================
  async function ensureLovableButton() {
    const info = await miro.board.getInfo();
    const boardId = info && info.id ? info.id : null;

    const frame = await findTargetFrame();
    if (!frame) {
      await notifyError(`Frame "${TARGET_FRAME_TITLE}" not found. Create a frame titled "${TARGET_FRAME_TITLE}".`);
      return null;
    }

    await setAppDataKey(APPDATA_FRAME_ID_KEY, frame.id);

    const desiredContent = toHtmlButtonContent(boardId);

    const existing = await findExistingButtonShape();
    if (existing && existing.type === "shape") {
      try {
        // Keep content up to date (including the hyperlink).
        if (typeof desiredContent === "string" && desiredContent && existing.content !== desiredContent) {
          existing.content = desiredContent;
          if (typeof existing.sync === "function") await existing.sync();
        }
      } catch (e) {}
      try {
        if (typeof frame.add === "function") {
          await frame.add(existing);
          if (typeof frame.sync === "function") await frame.sync();
        }
      } catch (e) {}
      await setAppDataKey(APPDATA_BUTTON_ID_KEY, existing.id);
      return existing;
    }

    const fx = Number.isFinite(frame.x) ? frame.x : 0;
    const fy = Number.isFinite(frame.y) ? frame.y : 0;
    const fw = Number.isFinite(frame.width) ? frame.width : 1600;
    const fh = Number.isFinite(frame.height) ? frame.height : 900;

    const btnW = 340;
    const btnH = 120;

    const bx = fx + (fw / 2) - (btnW / 2) - 40;
    const by = fy - (fh / 2) + (btnH / 2) + 40;

    const btn = await miro.board.createShape({
      content: desiredContent,
      shape: "round_rectangle",
      x: bx,
      y: by,
      width: btnW,
      height: btnH
    });

    try {
      if (btn && typeof frame.add === "function") {
        await frame.add(btn);
        if (typeof frame.sync === "function") await frame.sync();
      }
    } catch (e) {}

    if (btn && btn.id) {
      await setAppDataKey(APPDATA_BUTTON_ID_KEY, btn.id);
    }

    return btn;
  }

  function buildBoardUrlFromId(boardId) {
    const encoded = encodeURIComponent(String(boardId || ""));
    return `https://miro.com/app/board/${encoded}/`;
  }

  // ============================
  // Wrapper prompt (UPDATED as requested)
  // ============================
  function buildLovablePrompt(boardId) {
    const boardUrl = buildBoardUrlFromId(boardId);

    return [
      `Build a web app using ONLY the content inside the frame titled "${TARGET_FRAME_TITLE}" (case-insensitive) on this Miro board.`,
      ``,
      `Miro MCP is connected in this Lovable workspace.`,
      `Board URL: ${boardUrl}`,
      `Scope: ONLY content inside the frame titled "${TARGET_FRAME_TITLE}". Ignore everything else.`,
      ``,
      `MCP procedure (strict):`,
      `1) Call context_explore on the board. Find the frame whose title matches "${TARGET_FRAME_TITLE}" and capture its item id.`,
      `2) Call board_list_items filtered to that frame as parent/container. Only include: doc, sticky_note, text.`,
      `3) Inside that frame, find EXACTLY ONE Miro Doc (doc-format). Call doc_get on that doc.`,
      `   - Treat the returned markdown as the MASTER SPEC and follow it verbatim.`,
      `   - Do not reinterpret or paraphrase it; implement it.`,
      `4) Collect ALL sticky_note texts inside that same frame (expected: 6).`,
      `   - Treat them as additional requirements / selected inputs.`,
      `   - If the master spec contains a placeholder for "CRITERIA_SUBSET_JSON", fill it best-effort using exactly those 6 sticky texts.`,
      `5) Build the app end-to-end in Lovable (MVP first), strictly based on the master spec + those 6 stickies.`,
      ``,
      `Deliverable:`,
      `- Generate the full working mini-app in Lovable.`,
      `- Keep requirements traceable: reference the Miro doc id and sticky ids you used.`
    ].join("\n");
  }

  function buildLovableUrl(prompt) {
    const enc = encodeURIComponent(prompt);
    return LOVABLE_BASE_URL + enc;
  }

  async function openLovableFromBoard(boardId) {
    const prompt = buildLovablePrompt(boardId);
    const url = buildLovableUrl(prompt);

    const frame = await findTargetFrame();
    if (!frame) {
      await notifyError(`Frame "${TARGET_FRAME_TITLE}" not found.`);
      return;
    }

    // Place the link inside the Lovable frame, right next to the Lovable button.
    // Keep the text clean (no raw URL rendering).
    let btn = await findExistingButtonShape();
    if (!btn) {
      btn = await ensureLovableButton();
    }
    if (!btn) {
      await notifyError("Lovable button not found.");
      return;
    }

    const fx = Number.isFinite(frame.x) ? frame.x : 0;
    const fy = Number.isFinite(frame.y) ? frame.y : 0;
    const fw = Number.isFinite(frame.width) ? frame.width : 1600;
    const fh = Number.isFinite(frame.height) ? frame.height : 900;

    const bx = Number.isFinite(btn.x) ? btn.x : fx;
    const by = Number.isFinite(btn.y) ? btn.y : fy;
    const bw = Number.isFinite(btn.width) ? btn.width : 340;

    const textW = 420;
    const pad = 40;
    const gapX = 30;

    let x = bx + (bw / 2) + gapX + (textW / 2);
    let y = by;

    // Clamp inside the frame bounds.
    const left = fx - (fw / 2);
    const right = fx + (fw / 2);
    const top = fy - (fh / 2);
    const bottom = fy + (fh / 2);

    x = Math.max(left + (textW / 2) + pad, Math.min(x, right - (textW / 2) - pad));
    y = Math.max(top + pad, Math.min(y, bottom - pad));

    const html =
      `<p>` +
      `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">` +
      `<strong>Open Lovable (autosubmit)</strong>` +
      `</a>` +
      `</p>`;

    const textItem = await miro.board.createText({ content: html, x, y, width: textW });

    try {
      if (textItem && typeof frame.add === "function") {
        await frame.add(textItem);
        if (typeof frame.sync === "function") await frame.sync();
      }
    } catch (e) {}

    try {
      await miro.board.viewport.zoomTo(textItem);
    } catch (e) {}

    await notifyInfo("Lovable link created next to the button.");
  }

  // ============================
  // OKR: Analyze selected PDF (kept)
  // ============================
  async function callOkrBackend(boardId, itemId) {
    const payload = { boardId, itemId, model: MODEL };

    const res = await fetch(`${BACKEND_URL}/api/analyze-selected-pdf`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const text = await res.text();
    if (!res.ok) throw new Error(`Backend ${res.status}: ${text}`);

    try {
      return JSON.parse(text);
    } catch (e) {
      return { raw: text };
    }
  }

  async function getSelectedDocumentItem() {
    const sel = await miro.board.getSelection();
    if (!sel || !sel.items || !sel.items.length) return null;
    const it = sel.items[0];
    if (it.type === "document") return it;
    return null;
  }

  // Toolbar button
  document.getElementById("btnAnalyze").addEventListener("click", async () => {
    try {
      const info = await miro.board.getInfo();
      const boardId = info && info.id ? info.id : null;
      if (!boardId) throw new Error("No boardId");

      const selected = await getSelectedDocumentItem();
      if (!selected) {
        await notifyError("Select a PDF Document item first.");
        return;
      }

      await notifyInfo("Analyzing PDFâ€¦ (server call)");
      const result = await callOkrBackend(boardId, selected.id);

      if (result && result.createdDocId) {
        await notifyInfo(`OKR Doc created: ${result.createdDocId}`);
      } else if (result && result.createdTextId) {
        await notifyInfo(`Doc creation failed; text created: ${result.createdTextId}`);
      } else {
        await notifyInfo("Done.");
      }
    } catch (e) {
      await notifyError(e && e.message ? e.message : String(e));
    }
  });

  // ============================
  // Table â†’ Stickies (kept)
  // ============================
  document.getElementById("btnTable").addEventListener("click", async () => {
    try {
      const info = await miro.board.getInfo();
      const boardId = info && info.id ? info.id : null;
      if (!boardId) throw new Error("No boardId");

      await notifyInfo("Calling table-to-stickies backendâ€¦");
      const res = await fetch(`${BACKEND_URL}/api/table-to-stickies-mcp`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ boardId })
      });
      const text = await res.text();
      if (!res.ok) throw new Error(`Backend ${res.status}: ${text}`);

      await notifyInfo("Stickies created.");
    } catch (e) {
      await notifyError(e && e.message ? e.message : String(e));
    }
  });

  // ============================
  // Right-click action for PDFs (kept)
  // ============================
  miro.board.experimental.action.register("analyze-okrs", async () => {
    const info = await miro.board.getInfo();
    const boardId = info && info.id ? info.id : null;
    if (!boardId) {
      await notifyError("No boardId");
      return;
    }
    const selected = await getSelectedDocumentItem();
    if (!selected) {
      await notifyError("Select a PDF Document item first.");
      return;
    }

    await notifyInfo("Analyzing PDFâ€¦ (server call)");
    try {
      const result = await callOkrBackend(boardId, selected.id);
      if (result && result.createdDocId) {
        await notifyInfo(`OKR Doc created: ${result.createdDocId}`);
      } else if (result && result.createdTextId) {
        await notifyInfo(`Doc creation failed; text created: ${result.createdTextId}`);
      } else {
        await notifyInfo("Done.");
      }
    } catch (e) {
      await notifyError(e && e.message ? e.message : String(e));
    }
  });

  // ============================
  // Selection click on Lovable shape
  // ============================
  let selectionHandling = false;

  miro.board.ui.on("selection:update", async (evt) => {
    if (selectionHandling) return;
    selectionHandling = true;
    try {
      const items = evt && evt.items ? evt.items : [];
      if (!items.length) return;

      const selected = items[0];
      if (!selected || selected.type !== "shape") return;

      // Make sure we are matching our button
      const full = await getShapeById(selected.id);
      if (!full) return;

      if (!shapeHasMarker(full) && !shapeLooksLikeButton(full)) return;

      const info = await miro.board.getInfo();
      const boardId = info && info.id ? info.id : null;
      if (!boardId) {
        await notifyError("No boardId available.");
        return;
      }

      await openLovableFromBoard(boardId);

      try { await miro.board.deselect(selected.id); } catch (e) {}
    } finally {
      selectionHandling = false;
    }
  });

  // ============================
  // Icon click (setup)
  // ============================
  await miro.board.ui.on("icon:click", async () => {
    try {
      const btn = await ensureLovableButton();
      if (btn && btn.id) {
        await notifyInfo(`Button ready. Click "${BUTTON_LABEL_TEXT}" on the board. PDFs: right-click â†’ Analyze OKR.`);
      }
    } catch (e) {
      await notifyError(e && e.message ? e.message : String(e));
    }
  });

  // ============================
  // Bootstrap
  // ============================
  try {
    await ensureLovableButton();
    await notifyInfo(`Ready. Click the board button "${BUTTON_LABEL_TEXT}". PDFs: right-click â†’ Analyze OKR.`);
  } catch (e) {
    await notifyError(e && e.message ? e.message : String(e));
  }
})();
</script>
</body>
</html>
