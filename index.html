<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Miro â†’ Lovable (Build with URL) + PDFâ†’OKR</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
</head>
<body>
<script>
(async function init() {
  // ============================
  // CONFIG
  // ============================
  const BACKEND_URL = "https://miro-app-mcp.vercel.app";
  const MODEL = "gpt-5.2";

  // --- Lovable button config ---
  const TARGET_FRAME_TITLE = "lovable"; // Frame title to scope content (case-insensitive)
  const BUTTON_MARKER = "DT_LOVABLE_BUTTON_V1";
  const BUTTON_LABEL_TEXT = "ðŸš€ Lovable: Generate App";
  const BUTTON_SUBTEXT = `Frame: ${TARGET_FRAME_TITLE}`;
  const LOVABLE_BASE_URL = "https://lovable.dev/?autosubmit=true#prompt=";

  const APPDATA_BUTTON_ID_KEY = "dt_lovable_button_id_v1";
  const APPDATA_FRAME_ID_KEY = "dt_lovable_frame_id_v1";

  let lastLaunchAt = 0;

  // --- OKR Custom Action config ---
  const OKR_ACTION_EVENT = "analyze-okr";
  const OKR_CUSTOM_EVENT = `custom:${OKR_ACTION_EVENT}`;

  function truncate80(s) {
    const t = String(s || "").replace(/\s+/g, " ").trim();
    return t.length > 80 ? (t.slice(0, 77) + "...") : t;
  }

  async function notifyInfo(msg) {
    try { await miro.board.notifications.showInfo(truncate80(msg)); } catch (e) {}
  }

  async function notifyError(msg) {
    try { await miro.board.notifications.showError(truncate80(msg)); } catch (e) {}
  }

  // ============================
  // AppData helpers
  // ============================
  async function getAppDataKey(key) {
    try {
      const v = await miro.board.getAppData(key);
      return v;
    } catch (e1) {
      try {
        const all = await miro.board.getAppData();
        if (all && typeof all === "object") {
          return all[key];
        }
      } catch (e2) {}
    }
    return undefined;
  }

  async function setAppDataKey(key, value) {
    try {
      await miro.board.setAppData(key, value);
      return true;
    } catch (e1) {
      try {
        const obj = {};
        obj[key] = value;
        await miro.board.setAppData(obj);
        return true;
      } catch (e2) {}
    }
    return false;
  }

  // ============================
  // Lovable: Frame + Button
  // ============================
  function normalizeTitle(s) {
    return String(s || "").trim().toLowerCase();
  }

  async function findTargetFrame() {
    const frames = await miro.board.get({ type: ["frame"] });
    const wanted = normalizeTitle(TARGET_FRAME_TITLE);

    if (Array.isArray(frames)) {
      for (const f of frames) {
        const t = normalizeTitle(f && f.title);
        if (t === wanted) return f;
      }
    }
    return null;
  }

  function shapeHasMarker(shape) {
    const content = String(shape && shape.content ? shape.content : "");
    return content.indexOf(BUTTON_MARKER) !== -1;
  }

  function shapeLooksLikeButton(shape) {
    const content = String(shape && shape.content ? shape.content : "").toLowerCase();
    return content.indexOf("lovable") !== -1 && content.indexOf("generate") !== -1;
  }

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }

  function toHtmlButtonContent(boardId) {
    // Fallback to old content if boardId isn't available for any reason.
    if (!boardId) {
      return (
        `<p><strong>${escapeHtml(BUTTON_LABEL_TEXT)}</strong></p>` +
        `<p style="font-size:12px;opacity:.8;">${escapeHtml(BUTTON_SUBTEXT)}</p>` +
        `<p style="font-size:10px;opacity:.01;">${BUTTON_MARKER}</p>`
      );
    }

    const prompt = buildLovablePrompt(boardId);
    const url = buildLovableUrl(prompt);

    // Shapes support <a> tags in content; using a normal hyperlink improves reliability
    // for collaborators because it no longer depends on the app runtime events.
    return (
      `<p><strong>` +
        `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit;">` +
          `${escapeHtml(BUTTON_LABEL_TEXT)}` +
        `</a>` +
      `</strong></p>` +
      `<p style="font-size:12px;opacity:.8;">${escapeHtml(BUTTON_SUBTEXT)}</p>` +
      `<p style="font-size:10px;opacity:.01;">${BUTTON_MARKER}</p>`
    );
  }

  async function getShapeById(id) {
    if (!id) return null;
    try {
      const arr = await miro.board.get({ id: id });
      if (Array.isArray(arr) && arr.length) return arr[0];
      if (arr && typeof arr === "object") return arr;
    } catch (e) {}
    return null;
  }

  async function findExistingButtonShape() {
    const savedId = await getAppDataKey(APPDATA_BUTTON_ID_KEY);
    if (savedId) {
      const item = await getShapeById(savedId);
      if (item && item.type === "shape") return item;
    }

    const shapes = await miro.board.get({ type: ["shape"] });
    if (Array.isArray(shapes)) {
      for (const s of shapes) {
        if (shapeHasMarker(s)) return s;
      }
      for (const s of shapes) {
        if (shapeLooksLikeButton(s)) return s;
      }
    }
    return null;
  }

  async function ensureLovableButton() {
    const frame = await findTargetFrame();
    if (!frame) {
      await notifyError(`Frame "${TARGET_FRAME_TITLE}" not found. Create a frame titled "${TARGET_FRAME_TITLE}".`);
      return null;
    }

    await setAppDataKey(APPDATA_FRAME_ID_KEY, frame.id);

    // We want the button content to include a real hyperlink, which needs the boardId.
    let boardId = null;
    try {
      const info = await miro.board.getInfo();
      boardId = info && info.id ? info.id : null;
    } catch (e) {}

    const desiredContent = toHtmlButtonContent(boardId);

    const existing = await findExistingButtonShape();
    if (existing && existing.type === "shape") {
      // Keep content up-to-date (so the button label stays a working hyperlink).
      try {
        if (typeof desiredContent === "string" && desiredContent && existing.content !== desiredContent) {
          existing.content = desiredContent;
          if (typeof existing.sync === "function") await existing.sync();
        }
      } catch (e) {}

      try {
        if (typeof frame.add === "function") {
          await frame.add(existing);
          if (typeof frame.sync === "function") await frame.sync();
        }
      } catch (e) {}
      await setAppDataKey(APPDATA_BUTTON_ID_KEY, existing.id);
      return existing;
    }

    const fx = Number.isFinite(frame.x) ? frame.x : 0;
    const fy = Number.isFinite(frame.y) ? frame.y : 0;
    const fw = Number.isFinite(frame.width) ? frame.width : 1600;
    const fh = Number.isFinite(frame.height) ? frame.height : 900;

    const btnW = 340;
    const btnH = 120;

    const bx = fx + (fw / 2) - (btnW / 2) - 40;
    const by = fy - (fh / 2) + (btnH / 2) + 40;

    const btn = await miro.board.createShape({
      content: desiredContent,
      shape: "round_rectangle",
      x: bx,
      y: by,
      width: btnW,
      height: btnH
    });

    try {
      if (btn && typeof frame.add === "function") {
        await frame.add(btn);
        if (typeof frame.sync === "function") await frame.sync();
      }
    } catch (e) {}

    if (btn && btn.id) {
      await setAppDataKey(APPDATA_BUTTON_ID_KEY, btn.id);
    }

    return btn;
  }

  function buildBoardUrlFromId(boardId) {
    const encoded = encodeURIComponent(String(boardId || ""));
    return `https://miro.com/app/board/${encoded}/`;
  }

  // ============================
  // Wrapper prompt (UPDATED as requested)
  // ============================
  function buildLovablePrompt(boardId) {
    const boardUrl = buildBoardUrlFromId(boardId);

    return [
      `Build a web app using ONLY the content inside the frame titled "${TARGET_FRAME_TITLE}" (case-insensitive) on this Miro board.`,
      ``,
      `Miro MCP is connected in this Lovable workspace.`,
      `Board URL: ${boardUrl}`,
      `Scope: ONLY content inside the frame titled "${TARGET_FRAME_TITLE}". Ignore everything else.`,
      ``,
      `MCP procedure (strict):`,
      `1) Call context_explore on the board. Find the frame whose title matches "${TARGET_FRAME_TITLE}" and capture its item id.`,
      `2) Call board_list_items filtered to that frame as parent/container. Only include: doc, sticky_note, text.`,
      `3) Inside that frame, find EXACTLY ONE Miro Doc (doc-format). Call doc_get on that doc.`,
      `   - Treat the returned markdown as the MASTER SPEC and follow it verbatim.`,
      `   - Do not reinterpret or paraphrase it; implement it.`,
      `4) Collect ALL sticky_note texts inside that same frame (expected: 6).`,
      `   - Treat them as additional requirements / selected inputs.`,
      `   - If the master spec contains a placeholder for "CRITERIA_SUBSET_JSON", fill it best-effort using exactly those 6 sticky texts.`,
      `5) Build the app end-to-end in Lovable (MVP first), strictly based on the master spec + those 6 stickies.`,
      ``,
      `Deliverable:`,
      `- Generate the full working mini-app in Lovable.`,
      `- Keep requirements traceable: reference the Miro doc id and sticky ids you used.`
    ].join("\n");
  }

  function buildLovableUrl(prompt) {
    const enc = encodeURIComponent(prompt);
    return LOVABLE_BASE_URL + enc;
  }

  async function openLovableFromBoard(boardId) {
    const prompt = buildLovablePrompt(boardId);
    const url = buildLovableUrl(prompt);

    const frame = await findTargetFrame();
    if (!frame) {
      await notifyError(`Frame "${TARGET_FRAME_TITLE}" not found.`);
      return;
    }

    // Ensure button exists; we'll place the link right next to it inside the frame.
    const btn = await ensureLovableButton();
    if (!btn) {
      await notifyError("Lovable button not found.");
      return;
    }

    const fx = Number.isFinite(frame.x) ? frame.x : 0;
    const fy = Number.isFinite(frame.y) ? frame.y : 0;
    const fw = Number.isFinite(frame.width) ? frame.width : 1600;
    const fh = Number.isFinite(frame.height) ? frame.height : 900;

    const bx = Number.isFinite(btn.x) ? btn.x : fx;
    const by = Number.isFinite(btn.y) ? btn.y : fy;
    const bw = Number.isFinite(btn.width) ? btn.width : 340;

    const textW = 420;
    const pad = 40;
    const gapX = 30;

    let x = bx + (bw / 2) + gapX + (textW / 2);
    let y = by;

    // Clamp inside the frame bounds.
    const left = fx - (fw / 2);
    const right = fx + (fw / 2);
    const top = fy - (fh / 2);
    const bottom = fy + (fh / 2);

    x = Math.max(left + (textW / 2) + pad, Math.min(x, right - (textW / 2) - pad));
    y = Math.max(top + pad, Math.min(y, bottom - pad));

    // Short, clean link only (no raw URL line, no long explanatory text).
    const html =
      `<p>` +
      `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">` +
      `<strong>Open Lovable (autosubmit)</strong>` +
      `</a>` +
      `</p>`;

    const textItem = await miro.board.createText({ content: html, x, y, width: textW });

    try {
      if (textItem && typeof frame.add === "function") {
        await frame.add(textItem);
        if (typeof frame.sync === "function") await frame.sync();
      }
    } catch (e) {}

    try {
      await miro.board.viewport.zoomTo(textItem);
    } catch (e) {}

    await notifyInfo("Lovable link created inside the frame (next to button).");
  }

  // ============================
  // OKR: Analyze selected PDF (kept)
  // ============================
  async function callOkrBackend(boardId, itemId) {
    const payload = { boardId, itemId, model: MODEL };

    const res = await fetch(`${BACKEND_URL}/api/analyze-selected-pdf`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const text = await res.text();
    if (!res.ok) throw new Error(`Backend ${res.status}: ${text}`);

    try {
      return JSON.parse(text);
    } catch (e) {
      return { raw: text };
    }
  }

  async function runOkrForCurrentSelection() {
    const boardInfo = await miro.board.getInfo();
    const boardId = boardInfo && boardInfo.id ? boardInfo.id : null;
    if (!boardId) throw new Error("No boardId available.");

    const selection = await miro.board.getSelection();
    if (!Array.isArray(selection) || selection.length !== 1) {
      await notifyError("Select exactly 1 PDF document.");
      return;
    }

    const item = selection[0];
    if (!item || !item.id) {
      await notifyError("Selection has no item id.");
      return;
    }

    await notifyInfo("OKR analysis startedâ€¦");

    const data = await callOkrBackend(boardId, item.id);

    if (data && data.createdDocId) {
      await notifyInfo("OKR doc created on board.");
      return;
    }
    if (data && data.createdTextId) {
      await notifyInfo("OKR output created (text fallback).");
      return;
    }

    await notifyInfo("OKR analysis finished.");
  }

  await miro.board.ui.on(OKR_CUSTOM_EVENT, async () => {
    try {
      await runOkrForCurrentSelection();
    } catch (e) {
      await notifyError(e && e.message ? e.message : String(e));
    }
  });

  try { await miro.board.experimental.action.deregister(OKR_ACTION_EVENT); } catch (e) {}

  await miro.board.experimental.action.register({
    event: OKR_ACTION_EVENT,
    ui: {
      label: { en: "Analyze OKR" },
      icon: "chat-two",
      description: "Analyze selected PDF and write the OKR result to a board doc."
    },
    scope: "local",
    selection: "single",
    predicate: { type: "document" },
    contexts: { item: {} }
  });

  // ============================
  // Board button click (selection:update)
  // ============================
  let selectionHandling = false;

  await miro.board.ui.on("selection:update", async (event) => {
    if (selectionHandling) return;
    selectionHandling = true;

    try {
      const items = event && Array.isArray(event.items) ? event.items : [];
      if (items.length !== 1) return;

      const selected = items[0];
      if (!selected || selected.type !== "shape") return;

      const btnId = await getAppDataKey(APPDATA_BUTTON_ID_KEY);
      const isOurButton =
        (btnId && selected.id === btnId) ||
        shapeHasMarker(selected) ||
        shapeLooksLikeButton(selected);

      if (!isOurButton) return;

      const now = Date.now();
      if (now - lastLaunchAt < 2500) return;
      lastLaunchAt = now;

      const info = await miro.board.getInfo();
      const boardId = info && info.id ? info.id : null;
      if (!boardId) {
        await notifyError("No boardId available.");
        return;
      }

      await openLovableFromBoard(boardId);

      try { await miro.board.deselect(selected.id); } catch (e) {}
    } finally {
      selectionHandling = false;
    }
  });

  // ============================
  // Icon click (setup)
  // ============================
  await miro.board.ui.on("icon:click", async () => {
    try {
      const btn = await ensureLovableButton();
      if (btn && btn.id) {
        await notifyInfo(`Button ready. Click "${BUTTON_LABEL_TEXT}" on the board. PDFs: right-click â†’ Analyze OKR.`);
      }
    } catch (e) {
      await notifyError(e && e.message ? e.message : String(e));
    }
  });

  // ============================
  // Bootstrap
  // ============================
  try {
    await ensureLovableButton();
    await notifyInfo(`Ready. Click the board button "${BUTTON_LABEL_TEXT}". PDFs: right-click â†’ Analyze OKR.`);
  } catch (e) {
    await notifyError(e && e.message ? e.message : String(e));
  }
})();
</script>
</body>
</html>
