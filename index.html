<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Miro â†’ Lovable (Build with URL)</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
</head>
<body>
<script>
(async function init() {
  // ============================
  // CONFIG
  // ============================
  const TARGET_FRAME_TITLE = "lovable"; // Frame title to scope content (case-insensitive)
  const BUTTON_MARKER = "DT_LOVABLE_BUTTON_V1";
  const BUTTON_LABEL_TEXT = "ðŸš€ Lovable: Generate App";
  const BUTTON_SUBTEXT = `Frame: ${TARGET_FRAME_TITLE}`;
  const LOVABLE_BASE_URL = "https://lovable.dev/?autosubmit=true#prompt=";

  const APPDATA_BUTTON_ID_KEY = "dt_lovable_button_id_v1";
  const APPDATA_FRAME_ID_KEY = "dt_lovable_frame_id_v1";

  let lastLaunchAt = 0;

  function truncate80(s) {
    const t = String(s || "").replace(/\s+/g, " ").trim();
    return t.length > 80 ? (t.slice(0, 77) + "...") : t;
  }

  async function notifyInfo(msg) {
    try { await miro.board.notifications.showInfo(truncate80(msg)); } catch (e) {}
  }

  async function notifyError(msg) {
    try { await miro.board.notifications.showError(truncate80(msg)); } catch (e) {}
  }

  async function getAppDataKey(key) {
    try {
      const v = await miro.board.getAppData(key);
      return v;
    } catch (e1) {
      try {
        const all = await miro.board.getAppData();
        if (all && typeof all === "object") {
          return all[key];
        }
      } catch (e2) {}
    }
    return undefined;
  }

  async function setAppDataKey(key, value) {
    try {
      await miro.board.setAppData(key, value);
      return true;
    } catch (e1) {
      try {
        const obj = {};
        obj[key] = value;
        await miro.board.setAppData(obj);
        return true;
      } catch (e2) {}
    }
    return false;
  }

  function normalizeTitle(s) {
    return String(s || "").trim().toLowerCase();
  }

  async function findTargetFrame() {
    const frames = await miro.board.get({ type: ["frame"] });
    const wanted = normalizeTitle(TARGET_FRAME_TITLE);

    if (Array.isArray(frames)) {
      for (const f of frames) {
        const t = normalizeTitle(f && f.title);
        if (t === wanted) return f;
      }
    }
    return null;
  }

  function shapeHasMarker(shape) {
    const content = String(shape && shape.content ? shape.content : "");
    return content.indexOf(BUTTON_MARKER) !== -1;
  }

  function shapeLooksLikeButton(shape) {
    const content = String(shape && shape.content ? shape.content : "").toLowerCase();
    return content.indexOf("lovable") !== -1 && content.indexOf("generate") !== -1;
  }

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }

  function toHtmlButtonContent() {
    return (
      `<p><strong>${escapeHtml(BUTTON_LABEL_TEXT)}</strong></p>` +
      `<p style="font-size:12px;opacity:.8;">${escapeHtml(BUTTON_SUBTEXT)}</p>` +
      `<p style="font-size:10px;opacity:.01;">${BUTTON_MARKER}</p>`
    );
  }

  async function getShapeById(id) {
    if (!id) return null;
    try {
      const arr = await miro.board.get({ id: id });
      if (Array.isArray(arr) && arr.length) return arr[0];
      if (arr && typeof arr === "object") return arr;
    } catch (e) {}
    return null;
  }

  async function findExistingButtonShape() {
    const savedId = await getAppDataKey(APPDATA_BUTTON_ID_KEY);
    if (savedId) {
      const item = await getShapeById(savedId);
      if (item && item.type === "shape") return item;
    }

    const shapes = await miro.board.get({ type: ["shape"] });
    if (Array.isArray(shapes)) {
      for (const s of shapes) {
        if (shapeHasMarker(s)) return s;
      }
      for (const s of shapes) {
        if (shapeLooksLikeButton(s)) return s;
      }
    }
    return null;
  }

  async function ensureLovableButton() {
    const frame = await findTargetFrame();
    if (!frame) {
      await notifyError(`Frame "${TARGET_FRAME_TITLE}" not found. Create a frame titled "${TARGET_FRAME_TITLE}".`);
      return null;
    }

    await setAppDataKey(APPDATA_FRAME_ID_KEY, frame.id);

    const existing = await findExistingButtonShape();
    if (existing && existing.type === "shape") {
      try {
        if (typeof frame.add === "function") {
          await frame.add(existing);
          if (typeof frame.sync === "function") await frame.sync();
        }
      } catch (e) {}
      await setAppDataKey(APPDATA_BUTTON_ID_KEY, existing.id);
      return existing;
    }

    const fx = Number.isFinite(frame.x) ? frame.x : 0;
    const fy = Number.isFinite(frame.y) ? frame.y : 0;
    const fw = Number.isFinite(frame.width) ? frame.width : 1600;
    const fh = Number.isFinite(frame.height) ? frame.height : 900;

    const btnW = 340;
    const btnH = 120;

    const bx = fx + (fw / 2) - (btnW / 2) - 40;
    const by = fy - (fh / 2) + (btnH / 2) + 40;

    const btn = await miro.board.createShape({
      content: toHtmlButtonContent(),
      shape: "round_rectangle",
      x: bx,
      y: by,
      width: btnW,
      height: btnH
    });

    try {
      if (btn && typeof frame.add === "function") {
        await frame.add(btn);
        if (typeof frame.sync === "function") await frame.sync();
      }
    } catch (e) {}

    if (btn && btn.id) {
      await setAppDataKey(APPDATA_BUTTON_ID_KEY, btn.id);
    }

    return btn;
  }

  function buildBoardUrlFromId(boardId) {
    const encoded = encodeURIComponent(String(boardId || ""));
    return `https://miro.com/app/board/${encoded}/`;
  }

  function buildLovablePrompt(boardId) {
    const boardUrl = buildBoardUrlFromId(boardId);
    return [
      "Build a web app from the following Miro board content.",
      "",
      "Miro MCP is connected in this Lovable workspace.",
      `Board URL: ${boardUrl}`,
      `Scope: ONLY content inside the frame titled "${TARGET_FRAME_TITLE}" (case-insensitive). Ignore everything else.`,
      "",
      "MCP procedure (strict):",
      "1) Call context_explore on the board. Find the frame whose title matches the scope title and capture its item id + url.",
      "2) Call board_list_items with a parent container filter set to that frame id. Include item types: document, sticky_note, text.",
      "3) For each document in that frame: call context_get to extract full HTML (treat as spec/prompt).",
      "4) For sticky notes: use their text/content as requirements, features, constraints, user stories.",
      "",
      "Deliverable:",
      "- Generate the application in Lovable end-to-end.",
      "- Prefer a simple, working MVP architecture first.",
      "- Keep requirements traceable: mention the Miro doc/sticky ids you used when translating into features."
    ].join("\n");
  }

  function buildLovableUrl(prompt) {
    const enc = encodeURIComponent(prompt);
    return LOVABLE_BASE_URL + enc;
  }

  async function writeLovableUrlToBoard(url, frame) {
    // Write a clickable/copyable link as a Text item near the lovable frame.
    const fx = frame && Number.isFinite(frame.x) ? frame.x : 0;
    const fy = frame && Number.isFinite(frame.y) ? frame.y : 0;
    const fw = frame && Number.isFinite(frame.width) ? frame.width : 1600;

    const x = fx + (fw / 2) + 380;
    const y = fy;

    const html =
      `<p><strong>Lovable Launch Link</strong></p>` +
      `<p style="font-size:12px;opacity:.85;">If popup is blocked, open this link:</p>` +
      `<p><a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">Open Lovable (autosubmit)</a></p>` +
      `<p style="font-size:11px;opacity:.7;">(If the link is not clickable in your UI, copy the full URL below.)</p>` +
      `<p style="font-size:10px;word-break:break-all;">${escapeHtml(url)}</p>`;

    try {
      await miro.board.createText({
        content: html,
        x,
        y
      });
      await notifyInfo("Lovable URL written to board.");
    } catch (e) {
      await notifyError("Could not write Lovable URL to board: " + (e && e.message ? e.message : String(e)));
    }
  }

async function openLovableFromBoard(boardId) {
  const prompt = buildLovablePrompt(boardId);
  const url = buildLovableUrl(prompt);

  const frame = await findTargetFrame();
  if (!frame) {
    await notifyError(`Frame "${TARGET_FRAME_TITLE}" not found.`);
    return;
  }

  // ALWAYS write to board (no popup attempts)
  const fx = Number.isFinite(frame.x) ? frame.x : 0;
  const fy = Number.isFinite(frame.y) ? frame.y : 0;
  const fw = Number.isFinite(frame.width) ? frame.width : 1600;

  const x = fx + (fw / 2) + 520;
  const y = fy;

  const html =
    `<p><strong>Lovable Launch Link</strong></p>` +
    `<p style="font-size:12px;opacity:.85;">Click the link below to start Lovable (autosubmit):</p>` +
    `<p><a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">Open Lovable (autosubmit)</a></p>` +
    `<p style="font-size:10px;word-break:break-all;opacity:.7;">${escapeHtml(url)}</p>`;

  const textItem = await miro.board.createText({ content: html, x, y });

  try {
    await miro.board.viewport.zoomTo(textItem);
  } catch (e) {
    // ignore
  }

  await notifyInfo("Lovable link created on board (next to frame).");
}


  let selectionHandling = false;

  await miro.board.ui.on("selection:update", async (event) => {
    if (selectionHandling) return;
    selectionHandling = true;

    try {
      const items = event && Array.isArray(event.items) ? event.items : [];
      if (items.length !== 1) return;

      const selected = items[0];
      if (!selected || selected.type !== "shape") return;

      const btnId = await getAppDataKey(APPDATA_BUTTON_ID_KEY);
      const isOurButton =
        (btnId && selected.id === btnId) ||
        shapeHasMarker(selected) ||
        shapeLooksLikeButton(selected);

      if (!isOurButton) return;

      const now = Date.now();
      if (now - lastLaunchAt < 2500) return;
      lastLaunchAt = now;

      const info = await miro.board.getInfo();
      const boardId = info && info.id ? info.id : null;
      if (!boardId) {
        await notifyError("No boardId available.");
        return;
      }

      await openLovableFromBoard(boardId);

      try { await miro.board.deselect(selected.id); } catch (e) {}
    } finally {
      selectionHandling = false;
    }
  });

  await miro.board.ui.on("icon:click", async () => {
    try {
      const btn = await ensureLovableButton();
      if (btn && btn.id) {
        await notifyInfo(`Button ready. Click "${BUTTON_LABEL_TEXT}" on the board.`);
      }
    } catch (e) {
      await notifyError(e && e.message ? e.message : String(e));
    }
  });

  try {
    await ensureLovableButton();
    await notifyInfo(`Ready. Click the board button "${BUTTON_LABEL_TEXT}".`);
  } catch (e) {
    await notifyError(e && e.message ? e.message : String(e));
  }
})();
</script>
</body>
</html>
